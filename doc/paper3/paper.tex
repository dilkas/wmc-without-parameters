\documentclass{article}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[UKenglish]{babel}
\usepackage{bm}
\usepackage{booktabs}
\usepackage[capitalise]{cleveref}
\usepackage{dashbox}
\usepackage{fullpage}
\usepackage[utf8]{inputenc}
\usepackage[UKenglish]{isodate}
\usepackage{mathtools}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{xfrac}
\usepackage[backgroundcolor=lightgray]{todonotes}
\usepackage{soul}
\usepackage{mathrsfs}
\usepackage{capt-of}
\usepackage{siunitx}

\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{conjecture}{Conjecture}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\theoremstyle{remark}
\newtheorem*{remark}{Remark}

\DeclareMathOperator{\im}{im}

\title{Weighted Model Counting Without Parameter Variables}

\begin{document}

\maketitle

\section{Introduction}

\paragraph{Notation.} For any propositional formula $\phi$ and $p, q \in
\mathbb{R}$, let $[\phi]^p_q\colon 2^X \to \mathbb{R}$ be a
pseudo-Boolean function defined as
\[
  [\phi]^p_q(Y) \coloneqq
  \begin{cases}
    p & \text{if } Y \models \phi \\
    q & \text{otherwise}
  \end{cases}
\]
for any $Y \subseteq X$.

\begin{lemma} \label{lemma:add_size}
  An ADD with $n$ variables has $\mathcal{O}(2^n)$ nodes.
\end{lemma}
\begin{proof}
  An ADD with $n$ variables can be, at most, a complete binary tree of height
  $n+1$ (as measured by the number of vertices). It would then have $2^0 + 2^1 +
  \dots + 2^n = 2^{n+1} = \mathcal{O}(2^n)$ nodes.
\end{proof}

\begin{lemma} \label{lemma:clause_time}
  Let $\phi$ be a conjunction of $n$ literals. Then the ADD representation of
  $[\phi]^p_q$ can be constructed in $\mathcal{O}(2^n)$ time for any $p, q \in
  \mathbb{R}$ such that $p \ne q$.
\end{lemma}
\begin{proof}
  The ADD representation of $\phi$ itself can be constructed with a sequence of
  $n-1$ calls to \texttt{apply} with one of the two operands in each call always
  a literal. The number of variables in the other operand then follows the
  sequence $1, 2, 3, \dots, n-1$. By \cref{lemma:add_size}, the numbers of nodes
  in the ADD representations of these operands is then $\mathcal{O}(2^1),
  \mathcal{O}(2^2), \dots, \mathcal{O}(2^{n-1})$. Since one of the operands is
  of constant size, the overall time complexity of all calls to \texttt{apply}
  is then
  \[
    \mathcal{O}(2^1) + \mathcal{O}(2^2) + \dots + \mathcal{O}(2^{n-1}) =
    \mathcal{O}(2^n).
  \]

  Let $\alpha$ be the ADD representation of $\phi$. Then the ADD representation
  of $[\phi]_q^p$ is $(p-q)\alpha + q$. As scalar operations can obviously be
  implemented in linear time, the overall complexity remains $\mathcal{O}(2^n)$.
\end{proof}

% NOTE: weights on literals other than the positive literals that correspond to
% variables in $X_P$ are redundant as they either are equal to one or duplicate
% an already-defined weight.
\begin{definition}[old WMC instance]
  An old WMC instance is a tuple $(\phi, X_I, X_P, w)$, where $X_I$ is the set
  of indicator variables, $X_P$ is the set of parameter variables, $\phi$ is a
  propositional formula over $X_I \cup X_P$, and $w\colon X_P \to \mathbb{R}$ is
  the weight function.
\end{definition}

\begin{definition}[new WMC instance]
  A new WMC instance is a tuple $(F, X, \omega)$, where $X$ is the set of
  variables, $F$ is a set of pseudo-Boolean functions $2^X \to \mathbb{R}$, and
  $\omega \in \mathbb{R}$ is the scaling factor.
\end{definition}

\paragraph{References.}
\begin{itemize}
\item Related work without publicly available implementations:
  \begin{itemize}
  \item direct compilation to SDDs \cite{DBLP:conf/ecsqaru/ChoiKD13}
  \item direct compilation to PSDDs, also eliminating parameter variables (a thesis)
  \item maybe two more papers
  \end{itemize}
\end{itemize}

\paragraph{Notes.}
\begin{itemize}
\item Apparently, the \textsc{DPMC} paper already shows that taking the first
  offered decomposition tree is best.
\item It is already well-known that WMC is FPT.
\end{itemize}

\section{Parameter Variable Elimination}

\paragraph{Notes.}
\begin{itemize}
\item Let $X_P$ be the set of parameter variable and $X_I$ be the set of
  indicator variables.
\item Parameter variables are either taken from the LMAP file (for encodings
  produced by Ace) or assumed to be the variables that have both weights equal
  to 1.
\item If a parameter variable in a clause is `negated', we can ignore the
  clause. We assume that there are no clauses with more than one instance of
  parameter variables.
\item The second \textbf{foreach} loop can be performed in constant time by
  representing $\phi'$ as a list and assuming that the two 'clauses' are
  adjacent in that list (and incorporating it into the first loop).
\item The $d$ map is constructed in $\mathcal{O}(|X_P|\log|X_P|)$ time (we want
  to use a data structure based on binary search trees rather than hashing).
\item \texttt{rename} can be implemented in $\mathcal{O}(\log |X_P|)$ time.
\item This may look like preprocessing, but all the transformations are local
  and thus can be incorporated into an encoding algorithm with no slowdown. In
  fact, if anything, the resulting algorithm would be slightly faster, as it
  would have less data to output.
\end{itemize}

\begin{algorithm}
  \caption{WMC instance transformation}
  \SetKwFunction{rename}{rename}
  \SetKwProg{Fn}{Function}{:}{}
  \KwData{an (old-format) WMC instance $(\phi, X_I, X_P, w)$}
  \KwResult{a (new-format) WMC instance $(F, X, \omega)$}
  $F \gets \emptyset$\;
  $\omega \gets 1$\;
  let $d\colon X_P \to \mathbb{N}$ be defined as $v \mapsto |\{ u \in X_P \mid u
  \le v \}|$\;
  \ForEach{clause $c \in \phi$}{
    \uIf{$c \cap X_P = \{ v \}$ for some $v$ \textnormal{\textbf{and}} $w(v) \ne
      1$}{
      \uIf{$|c| = 1$}{$\omega \gets \omega \times w(v)$\;}
      \Else{
        $F \gets F \cup \left\{ \left[ \bigwedge_{l \in c \setminus
              \{v\}} \neg l \right]^{w(v)}_1 \right\}$\;
      }
    }
    \ElseIf{$\{v \mid \neg v \in c\} \cap X_P  = \emptyset$}{
      $F \gets F \cup \{ [c]^1_0 \}$\;
    }
  }
  \ForEach{indicator variable $v \in X_I$}{
    \If{$\{[v]_1^p, [\neg v]_1^q\} \subseteq F$ for some $p$ and $q$}{
      $F \gets F \setminus \{ [v]_1^p, [\neg v]_1^q \} \cup \{ [v]_q^p
      \}$\;
    }
  }
  replace every variable $v$ in $F$ with $\rename{$v$}$\;
  \Return{$(F, X_I, \omega)$}\;
  \Fn{\rename{$v$}}{
    $S \gets \{u \in X_P \mid u \le v\}$\;
    \lIf{$S = \emptyset$}{\Return{$v$}}
    \Return{$v - d(\max S)$}\;
  }
\end{algorithm}

\section{Parameterised Complexity of \textsc{DPMC}}

\paragraph{Notes.}
\begin{itemize}
\item Summary of results
  \begin{itemize}
  \item We establish \textsc{DPMC} inference as fixed-parameter tractable.
  \item We experimentally show that \textsc{DPMC} is best on low-to-moderate
    treewidth instances, and cd06+c2d overtakes on higher treewidth instances.
  \end{itemize}
\item By \textsc{DPMC}, we always mean DMC+lg.
\end{itemize}

\paragraph{TODO}
\begin{itemize}
\item do a literature search focused around these papers
\item do I need to formally consider extending a pseudo-Boolean function to a
  bigger domain?
\item Introduce all the notation surrounding graphs ($\mathcal{V}$,
  $\mathcal{L}$, $\mathcal{C}$, etc.) (and be consistent with its usage)
\item Define:
  \begin{itemize}
  \item scalar operations on ADDs
  \item an ADD as a DAG.
  \item What does it mean for an ADD to `have' variables? Maybe refer to
    pseudo-Boolean function sensitivity.
  \item Formal definition of a previous WMC instance (CNF, literal weight
    function) and the new definition (set of $2^{X} \to \mathbb{R}_{\ge 0}$
    pseudo-Boolean functions and a constant). Note that the constant idea is
    borrowed from \texttt{bklm16}.
  \item Boolean formula in CNF (perhaps this is too trivial to define),
  \item primal graph of a CNF formula (a.k.a.
    Gaifman/(variable) interaction/connectivity/clique/representing graph),
  \item Bayesian network (I already have a definition of these last two),
  \item moralisation of a Bayesian network (or of any DAG),
  \end{itemize}
\end{itemize}

\begin{theorem}[\cite{DBLP:conf/ecai/KwisthoutBG10}, rephrased]
  BN Inference (for all algorithms that accept arbitrary instances) has a lower
  bound that's linear in the size of the BN and exponential in the treewidth of
  its moralisation (provide the exact formula).
\end{theorem}

\begin{definition}[\cite{DBLP:conf/cp/DudekPV20}, with some changes]
  Let $X$ be a set of Boolean variables, and $F$ be a set of pseudo-Boolean
  functions $2^X \to \mathbb{R}$. A \emph{project-join tree} (PJT) of $F$ is a
  tuple $(T, r, \gamma, \pi)$ where:
  \begin{itemize}
  \item $T$ is a tree with root $r \in \mathcal{V}(T)$,
  \item $\gamma\colon \mathcal{L}(T) \to F$ is a bijection between the leaves of
    $T$ and the pseudo-Boolean functions in $F$, and
  \item $\pi\colon \mathcal{V}(T) \setminus \mathcal{L}(T) \to 2^X$ is a
    labelling function on internal nodes.
  \end{itemize}
  Moreover, $(T, r, \gamma, \pi)$ must satisfy the following two properties:
  \begin{enumerate}
  \item $\{\pi(n) : n \in \mathcal{V}(T) \setminus \mathcal{L}(T)\}$ is a
    partition of $X$, and
  \item for each internal node $n \in \mathcal{V}(T) \setminus \mathcal{L}(T)$,
    variable $x \in \pi(n)$, and `clause' $c \in \im \gamma$ such that $x$
    appears in $c$, the leaf node $\gamma^{-1}(c)$ must be a descendant of $n$
    in $T$.
  \end{enumerate}
\end{definition}

\begin{definition}[\cite{DBLP:conf/cp/DudekPV20}] \label{def:size}
  \[
    \mathtt{Vars}(n) \coloneqq
    \begin{cases}
      \mathtt{Vars}(\gamma(n)) & \text{if } n \in \mathcal{L}(T) \\
      \left( \bigcup_{o \in \mathcal{C}(n)} \mathtt{Vars}(o) \right) \setminus
      \pi(n) & \text{if } n \not\in \mathcal{L}(T).
    \end{cases}
  \]
  \[
    \mathtt{size}(n) \coloneqq
    \begin{cases}
      |\mathtt{Vars}(n)| & \text{if } n \in \mathcal{L}(T) \\
      |\mathtt{Vars}(n) \cup \pi(n)| & \text{if } n \not\in \mathcal{L}(T).
    \end{cases}
  \]
  (Note that $\mathtt{size}(n)$ is the number of variables that can appear
  during the computation of $\delta(n)$ (excluding recursive calls).)
  The \emph{width} of a PJT $(T, r, \gamma, \pi)$ is
  $\mathtt{width}(T) \coloneqq \max_{n \in \mathcal{V}(T)} \mathtt{size}(n)$.
\end{definition}

\begin{theorem}[\cite{DBLP:conf/cp/DudekPV20}, rephrased, `ADD width is equal
  to the treewidth of the primal graph']
  Given a CNF formula $\phi$ with a tree decomposition of its primal graph of
  width $w$, Algorithm~2 (from \cite{DBLP:conf/cp/DudekPV20}) returns a
  PJT of $\phi$ of width at most $w+1$.
\end{theorem}

\begin{definition}[\cite{DBLP:journals/jct/RobertsonS84}, rephrased]
  A \emph{tree decomposition} of a graph $G$ is a pair $(T, \chi)$, where $T$ is
  a tree and $\chi\colon \mathcal{V}(T) \to 2^{\mathcal{V}(G)}$ is a labelling
  function, with the following properties:
  \begin{itemize}
  \item $\bigcup_{t \in \mathcal{V}(T)} \chi(t) = \mathcal{V}(G)$;
  \item for every edge $e \in \mathcal{E}(G)$, there exists $t \in
    \mathcal{V}(T)$ such that $e$ has both endpoints in $\chi(t)$;
  \item for all $t, t', t'' \in \mathcal{V}(T)$, if $t'$ is on the path between
    $t$ and $t''$, then $\chi(t) \cap \chi(t'') \subseteq \chi(t')$.
  \end{itemize}
  The \emph{width} of tree decomposition $(T, \chi)$ is $\max_{t \in
    \mathcal{V}(T)} |\chi(t)| - 1)$. The \emph{treewidth} of graph $G$ is the
  smallest $w$ such that $G$ has a tree decomposition of width $w$.
\end{definition}

\begin{definition}
  Let $f, g\colon 2^X \to \mathbb{R}$ be pseudo-Boolean functions. Operations
  such as addition and multiplication are defined pointwise as
  \[
    (f+g)(Y) \coloneqq f(Y)+g(Y),
  \]
  and
  \[
    (fg)(Y) \coloneqq f(Y)g(Y)
  \]
  for all $Y \subseteq X$.
\end{definition}

\begin{definition}
  Let $f\colon 2^X \to \mathbb{R}$ be a pseudo-Boolean function, and $x \in X$.
  Then $f|_{x=0}, f|_{x=1}\colon 2^X \to \mathbb{R}$ are \emph{restrictions} of
  $f$ defined as
  \[
    f|_{x=0}(Y) \coloneqq f(Y \setminus \{x\}),
  \]
  and
  \[
    f|_{x=1}(Y) \coloneqq f(Y \cup \{x\})
  \]
  for all $Y \subseteq X$.
\end{definition}

\begin{definition} \label{def:projection}
  Let $X$ be a set. For any $x \in X$, \emph{projection} $\exists_x$ is an
  endomorphism $\exists_x\colon \mathbb{R}^{2^X} \to \mathbb{R}^{2^X}$ defined
  as
  \[
    \exists_xf = f|_{x=1} + f|_{x=0}
  \]
  for any $f\colon 2^X \to \mathbb{R}$.
\end{definition}

\begin{lemma} \label{lemma:basic_ops}
  Let $f,g\colon 2^X \to \mathbb{R}$ be pseudo-Boolean functions represented by
  ADDs with $n$ and $m$ nodes, respectively, and $x \in X$. Then $f+g$ and $fg$
  can be computed in $\mathcal{O}(mn)$ time, and $\exists_xf$ can be computed in
  $\mathcal{O}(n^2)$ time.
\end{lemma}
\begin{proof}
  Addition and multiplication are implemented by \texttt{apply} algorithm which
  takes $\mathcal{O}(mn)$ time \cite{DBLP:journals/tc/Bryant86}. Projection
  consists of two restrictions and an addition by \cref{def:projection}. The
  computational complexity of restriction is dominated by the reduction
  operation that transforms a decision diagram into a minimal canonical form
  \cite{DBLP:journals/tc/Bryant86}. While the original reduction algorithm had a
  $\mathcal{O}(n \log n)$ complexity, caching can reduce it to $\mathcal{O}(n)$
  \cite{somenzi1998cudd}. Either way, the complexity of projection is still
  $\mathcal{O}(n^2)$.
\end{proof}

% NOTE: this is a rehash of equation (2) from the DPMC paper
\begin{definition} \label{def:abstraction}
  Let $(T, r, \gamma, \pi)$ be a PJT, and $X$ be the set of variables. The
  functionality of \textsc{DPMC} execution can be represented by $\delta(r)$,
  where $\delta\colon \mathcal{V}(T) \to \mathbb{R}^{2^X}$ is a recursive
  function defined as
  \begin{equation} \label{eq:execution}
    \delta(t) =
    \begin{cases}
      \gamma(t) & \text{if } t \in \mathcal{L}(T) \\
      \exists_{\pi(t)} \prod_{u \in \mathcal{C}(t)} \delta(u) & \text{otherwise.}
    \end{cases}
  \end{equation}
  The range of $\delta(r)$ then contains a single real number, i.e., the answer.
\end{definition}

% TODO: will need to rephrase this to fit my context
\begin{theorem}[Theorem~4 in \cite{DBLP:conf/cp/DudekPV20}, almost verbatim]
  Let $\phi$ be a CNF formula over a set $X$ of variables and $(S, \chi)$ be a
  tree decomposition of the primal graph of $\phi$ of width $w$. Then
  Algorithm~2 returns a PJT of $\phi$ of width at most $w+1$.
\end{theorem}

\begin{theorem}
  Let $(T, r, \gamma, \pi)$ be a PJT of width $k$. Then \textsc{DPMC} execution
  is fixed-parameter tractable with respect to the $k$. Specifically,
  \textsc{DPMC} execution time complexity is $\mathcal{O}(4^knm)$, where $n
  = |\mathcal{L}(T)|$ is the number of clauses/leaves, and $m$ is the number of
  variables.
\end{theorem}
% TODO: Use theorem 4 to show that the number of variables is
% bounded by primal treewidth
\begin{proof}
  \begin{itemize}
  \item Let us consider the overall complexity of all multiplications and
    projections throughout the recursive calls of $\delta$ in
    \cref{def:abstraction}. Clearly, the overall complexity is the sum of the
    complexity of operations performed within each call to $\delta$.
  \item Let $t \in \mathcal{L}(T)$ be a leaf. Note that
    $|\mathtt{Vars}(\gamma(t))| \le k$ by \cref{def:size}. Assuming that clauses
    have no repeating variables, it takes $\mathcal{O}(2^k)$ time to construct
    $\delta(t)$ by \cref{lemma:clause_time} and $\mathcal{O}(2^kn)$ time to
    construct all leaves of the PJT.
  \item Now let $t \in \mathcal{V}(T) \setminus \mathcal{L}(T)$ be an internal
    vertex, in which case we perform $|\mathcal{C}(t)|-1$ multiplications and
    $|\pi(t)|$ projections. Note that $|\mathcal{C}(t)| \le |\mathcal{L}(T)| =
    n$, $|\pi(t)| \le k$, and the ADDs involved can have up to $k$ variables.
    This means that each ADD has $\mathcal{O}(2^k)$ nodes (regardless of whether
    it comes from $\mathcal{C}(t)$ or from multiplications). Each such
    multiplication then takes $\mathcal{O}(4^k)$ time by \cref{lemma:basic_ops},
    and so all multiplications will take $\mathcal{O}(4^kn)$ time for $t$ and
    $\mathcal{O}(4^knm)$ time across all $t \in \mathcal{V}(T) \setminus
    \mathcal{L}(T)$ since the number of vertices in the PJT is bounded by the
    number of variables.
  \item Each variable is projected exactly once and is always projected from
    an ADD with at most $\mathcal{O}(2^k)$ nodes. Thus, the time complexity of
    projecting all variables is $\mathcal{O}(4^km)$.
  \item In total, we get $\mathcal{O}(2^kn)$ time for the leaves,
    $\mathcal{O}(4^knm)$ for multiplications, and $\mathcal{O}(4^km)$ for
    projections, resulting in $\mathcal{O}(4^knm)$ time in total.
  \end{itemize}
\end{proof}

\bibliographystyle{acm}
\bibliography{paper}

\end{document}