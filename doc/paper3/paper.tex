\documentclass[runningheads]{llncs}

\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\usepackage{amssymb}
\usepackage{mathtools}
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}
\usepackage[capitalise]{cleveref}
\usepackage{tikz}

\crefname{enumii}{Condition}{Conditions}

\begin{document}

%\title{Contribution Title\thanks{Supported by organization x.}}
\title{Weighted Model Counting Without Parameter Variables}

%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here

%\author{First Author\inst{1}\orcidID{0000-1111-2222-3333} \and
%Second Author\inst{2,3}\orcidID{1111-2222-3333-4444} \and
%Third Author\inst{3}\orcidID{2222--3333-4444-5555}}

%\authorrunning{F. Author et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.

%\institute{Princeton University, Princeton NJ 08544, USA \and
%Springer Heidelberg, Tiergartenstr. 17, 69121 Heidelberg, Germany
%\email{lncs@springer.com}\\
%\url{http://www.springer.com/gp/computer-science/lncs} \and
%ABC Institute, Rupert-Karls-University Heidelberg, Heidelberg, Germany\\
%\email{\{abc,lncs\}@uni-heidelberg.de}}

\maketitle              % typeset the header of the contribution

\begin{abstract}
  The abstract should briefly summarize the contents of the paper in
  150--250 words.

  \keywords{First keyword  \and Second keyword \and Another keyword.}
\end{abstract}

\section{Introduction}

\section{Pseudo-Boolean Functions}

\paragraph{Notation.} For any propositional formula $\phi$ over a set of
variables $X$ and $p, q \in \mathbb{R}$, let $[\phi]^p_q\colon 2^X \to
\mathbb{R}$ be a pseudo-Boolean function defined as
\[
  [\phi]^p_q(Y) \coloneqq
  \begin{cases}
    p & \text{if } Y \models \phi \\
    q & \text{otherwise}
  \end{cases}
\]
for any $Y \subseteq X$.

\begin{definition}[Operations] \label{def:operations}
  Let $f, g\colon 2^X \to \mathbb{R}$ be pseudo-Boolean functions, $x, y \in X$,
  $Y = \{y_i\}_{i=1}^n \subseteq X$, and $r \in \mathbb{R}$. Operations such as
  addition and multiplication are defined pointwise as
  \[
    (f+g)(Y) \coloneqq f(Y)+g(Y), \quad \text{and} \quad (f \cdot g)(Y)
    \coloneqq f(Y) \cdot g(Y).
  \]
  Note that this means that binary operations on pseudo-Boolean functions
  inherit properties such as associativity and commutativity. By not
  distinguishing between a real number and a pseudo-Boolean function that always
  returns that number, we can use the same definitions to define \emph{scalar}
  operations as
  \[
    (r+f)(Y) = r+f(Y), \quad \text{and} \quad (r \cdot f)(Y) = r \cdot f(Y).
  \]

  \emph{Restrictions} $f|_{x=0}, f|_{x=1}\colon 2^X \to \mathbb{R}$ of $f$ are
  defined as
  \[
    f|_{x=0}(Y) \coloneqq f(Y \setminus \{x\}), \quad \text{and} \quad
    f|_{x=1}(Y) \coloneqq f(Y \cup \{x\})
  \]
  for all $Y \subseteq X$.

  \emph{Projection} $\exists_x$ is an endomorphism $\exists_x\colon
  \mathbb{R}^{2^X} \to \mathbb{R}^{2^X}$ defined as
  \[
    \exists_xf \coloneqq f|_{x=1} + f|_{x=0}.
  \]
  Since projection is commutative (i.e., $\exists_x\exists_yf =
  \exists_y\exists_xf$) \cite{DBLP:conf/aaai/DudekPV20,DBLP:conf/cp/DudekPV20},
  we can define $\exists_Y\colon \mathbb{R}^{2^X} \to \mathbb{R}^{2^X}$ as
  $\exists_Y \coloneqq \exists_{y_1}\exists_{y_2}\dots\exists_{y_n}$. Throughout
  the paper, projection is assumed to have the lowest precedence (e.g.,
  $\exists_x fg = \exists_x (fg)$).
\end{definition}

NOTE: We list some properties of the operations on pseudo-Boolean functions
discussed in this section that can be conveniently represented using our syntax.
The proofs of all these properties follow directly from the definitions.

\begin{proposition}[Basic Properties] \label{prop:basic}
  For any propositional formulas $\phi$ and $\psi$, and $a, b, c, d \in
  \mathbb{R}$,
  \begin{itemize}
  \item $[\phi]^a_b = [\neg \phi]^b_a$;
  \item $c + [\phi]^a_b = [\phi]^{a+c}_{b+c}$;
  \item $c \cdot [\phi]^a_b = [\phi]^{ac}_{bc}$;
  \item $[\phi]^a_b \cdot [\phi]^c_d = [\phi]^{ac}_{bd}$;
  \item $[\phi]^1_0 \cdot [\psi]_0^1 = [\phi \land \psi]_0^1$.
  \end{itemize}
  And for any pair of pseudo-Boolean functions $f, g \colon 2^X \to \mathbb{R}$
  and $x \in  X$, $(fg)|_{x=i} = f|_{x=i} \cdot g|_{x=i}$ for $i = 0, 1$.
\end{proposition}

\paragraph{References.}
\begin{itemize}
\item Related work without publicly available implementations:
  \begin{itemize}
  \item direct compilation to SDDs \cite{DBLP:conf/ecsqaru/ChoiKD13}
  \item direct compilation to PSDDs, also eliminating parameter variables (a thesis)
  \item maybe two more papers
  \end{itemize}
\end{itemize}

\paragraph{Notes.}
\begin{itemize}
\item Weights on literals other than the positive literals that correspond to
  variables in $X_P$ are redundant as they either are equal to one or duplicate
  an already-defined weight.
\item Mention that formulas, clauses, and models are all treated as sets.
\end{itemize}

\section{Weighted Model Counting}

NOTE: Our definition of WMC is largely based on the standard definition
\cite{DBLP:journals/ai/ChaviraD08}, but explicitly partitions variables into
indicator and parameter variables.

\begin{definition}[WMC Instance]
  A \emph{WMC instance} is a tuple $(\phi, X_I, X_P, w)$, where $X_I$ is
  the set of indicator variables, $X_P$ is the set of parameter variables (with
  $X_I \cap X_P = \emptyset$), $\phi$ is a propositional formula in CNF over
  $X_I \cup X_P$, and $w\colon X_I \cup X_P \cup \{\neg x \mid x \in X_I \cup
  X_P\} \to \mathbb{R}$ is the weight function. The \emph{answer} of the
  instance is $\sum_{Y \models \phi} \prod_{Y \models l} w(l)$.
\end{definition}

\begin{remark}
  Encodings such as \texttt{cd05} and \texttt{cd06} are \emph{not} WMC
  encodings. Instead, they encode Bayesian network inference into instances of
  the \emph{minimum-cardinality} WMC problem, where the answer is defined to be
  $\sum_{Y \models \phi\text{, }|Y| = k} \prod_{Y \models l}
  w(l)$, where $k = \min_{Y \models \phi\text{, }Y \ne \emptyset}
  |Y|$, if $k$ exists, otherwise the answer is zero. This additional
  condition on model cardinality becomes necessary because these encodings
  eliminate clauses of the form $p \Rightarrow i$, where $p \in X_P$ is a
  parameter variable, and $i \in X_I$ is an indicator variable. Nonetheless, our
  transformation algorithm still works on such encodings, although the
  experimental results are discouraging because they use approximately twice as
  many indicator variables. For instance, each binary variable of a Bayesian
  network is encoded using two indicator variables while one would suffice.
\end{remark}

\begin{definition}[PBP Instance] \label{def:new_wmc}
  A \emph{pseudo-Boolean projection} (PBP) instance is a tuple $(F, X, \omega)$,
  where $X$ is the set of variables, $F$ is a set of pseudo-Boolean functions
  $2^X \to \mathbb{R}$, and $\omega \in \mathbb{R}$ is the scaling factor. The
  \emph{answer} of the instance is $\omega \cdot \left(\exists_X\prod_{f \in
      F}f\right)(\emptyset)$.
\end{definition}

NOTE: The constant is inspired by the \texttt{bklm16}
\cite{DBLP:conf/ecai/BartKLM16} encoding.

\section{Parameter Variable Elimination}

\paragraph{Notes.}
\begin{itemize}
\item Let $X_P$ be the set of parameter variable and $X_I$ be the set of
  indicator variables.
\item Parameter variables are either taken from the LMAP file (for encodings
  produced by Ace) or assumed to be the variables that have both weights equal
  to 1.
\item If a parameter variable in a clause is `negated', we can ignore the
  clause. We assume that there are no clauses with more than one instance of
  parameter variables.
\item The second \textbf{foreach} loop can be performed in constant time by
  representing $\phi'$ as a list and assuming that the two 'clauses' are
  adjacent in that list (and incorporating it into the first loop).
\item The $d$ map is constructed in $\mathcal{O}(|X_P|\log|X_P|)$ time (we want
  to use a data structure based on binary search trees rather than hashing).
\item \texttt{rename} can be implemented in $\mathcal{O}(\log |X_P|)$ time.
\item This may look like preprocessing, but all the transformations are local
  and thus can be incorporated into an encoding algorithm with no slowdown. In
  fact, if anything, the resulting algorithm would be slightly faster, as it
  would have less data to output.
\end{itemize}

\begin{algorithm}[t]
  \caption{WMC instance transformation}
  \label{alg:transformation}
  \SetKwFunction{rename}{rename}
  \SetKwProg{Fn}{Function}{:}{}
  \KwData{WMC instance $(\phi, X_I, X_P, w)$}
  \KwResult{PBP instance $(F, X, \omega)$}
  $F \gets \emptyset$\;
  $\omega \gets 1$\;
  let $d\colon X_P \to \mathbb{N}$ be defined as $p \mapsto |\{ o \in X_P \mid o
  \le p \}|$\;
  \ForEach{clause $c \in \phi$\label{line:foreach1start}}{
    \uIf{$c \cap X_P = \{ p \}$ for some $p$ \textnormal{\textbf{and}} $w(p) \ne
      1$}{
      \uIf{$|c| = 1$}{$\omega \gets \omega \times w(p)$\;}
      \Else{
        $F \gets F \cup \left\{ \left[ \bigwedge_{l \in c \setminus
              \{p\}} \neg l \right]^{w(p)}_1 \right\}$\;
      }
    }
    \ElseIf{$\{p \mid \neg p \in c\} \cap X_P  = \emptyset$}{
      $F \gets F \cup \{ [c]^1_0 \}$\; \label{line:foreach1end}
    }
  }
  \ForEach{indicator variable $v \in X_I$ \label{line:foreach2start}}{
    \If{$\{[v]_1^p, [\neg v]_1^q\} \subseteq F$ for some $p$ and $q$}{
      $F \gets F \setminus \{ [v]_1^p, [\neg v]_1^q \} \cup \{ [v]_q^p
      \}$\; \label{line:foreach2end}
    }
  }
  replace every variable $v$ in $F$ with $\rename{$v$}$\;
  \Return{$(F, X_I, \omega)$}\;
  \Fn{\rename{$v$}}{
    $S \gets \{u \in X_P \mid u \le v\}$\;
    \lIf{$S = \emptyset$}{\Return{$v$}}
    \Return{$v - d(\max S)$}\;
  }
\end{algorithm}

\subsection{Proof of Correctness}

\begin{theorem}[Early Projection
  \cite{DBLP:conf/aaai/DudekPV20,DBLP:conf/cp/DudekPV20},
  verbatim] \label{thm:early}
  Let $X$ and $Y$ be sets of variables. For all functions $f\colon 2^X \to
  \mathbb{R}$ and $g\colon 2^Y \to \mathbb{R}$, if $x \in X \setminus Y$, then
  $\exists_x (f \cdot g) = (\exists_x f) \cdot g$.
\end{theorem}

\begin{lemma} \label{lemma:sum}
  For any pseudo-Boolean function $f\colon 2^X \to \mathbb{R}$,
  \[
    (\exists_X f)(\emptyset) = \sum_{Y \subseteq X} f(Y).
  \]
\end{lemma}
\begin{proof}
  For base case, let $X = \{x\}$. Then
  \[
    (\exists_xf)(\emptyset) = (f|_{x=1} + f|_{x=0})(\emptyset) =
    f|_{x=1}(\emptyset) + f|_{x=0}(\emptyset) = \sum_{Y \subseteq \{x\}} f(Y).
  \]
  This easily extends to $|X| > 1$ by the definition of projection on sets of
  variables.
\end{proof}

% NOTE: mention that this is similar (but not equal) to the DPMC/ADDMC result
\begin{proposition} \label{prop:equivalence}
  Let $(\phi, X_I, X_P, w)$ be a WMC instance. Then
  \begin{equation}
  \left(\left\{[c]_0^1 \;\middle|\; c \in \phi\right\} \cup \left\{[x]_{w(\neg
        x)}^{w(x)} \;\middle|\; x \in X_I \cup X_P\right\}, X_I \cup X_P,
    1\right) \label{eq:new_wmc}
  \end{equation}
  is a PBP instance with the same answer.
\end{proposition}
\begin{proof}
  The answer of \cref{eq:new_wmc} is
  \begin{align*}
    \left(\exists_{X_I \cup X_P} \left(\prod_{c \in \phi} [c]_0^1\right) \prod_{x \in X_I \cup X_P} [x]_{w(\neg x)}^{w(x)} \right)(\emptyset) &= \sum_{Y \subseteq X_I \cup X_P} \left(\left(\prod_{c \in \phi} [c]_0^1 \right) \prod_{x \in X_I \cup X_P} [x]_{w(\neg x)}^{w(x)}\right)(Y) \\
&= \sum_{Y \subseteq X_I \cup X_P} \underbrace{\left(\prod_{c \in \phi} [c]_0^1\right)}_f(Y) \underbrace{\left(\prod_{x \in X_I \cup X_P} [x]_{w(\neg x)}^{w(x)}\right)}_g(Y)
  \end{align*}
  by \cref{lemma:sum}. Note that
  \[
    f(Y) =
    \begin{cases}
      1 & \text{if } Y \models \phi, \\
      0 & \text{otherwise},
    \end{cases}
    \quad
    \text{and}
    \quad
    g(Y) = \prod_{Y \models l} w(l),
  \]
  which means that
  \[
    \sum_{Y \subseteq X_I \cup X_P} f(Y)g(Y) = \sum_{Y \models \phi} \prod_{Y
      \models l} w(l)
  \]
  as required.
\end{proof}

\begin{theorem}[Correctness]
  \Cref{alg:transformation}, when given a WMC instance $(\phi, X_I, X_P,
  w)$, returns PBP instance with the same answer, provided the following
  conditions are satisfied:
  \begin{enumerate}
  \item for all indicator variables $i \in X_I$, $w(i) = w(\neg i) = 1$,
  \item and either
    \begin{enumerate}
    \item for all parameter variables $p \in X_P$, there is a non-empty family
      of literals $(l_i)_{i=1}^n$ such that \label{condition:d02}
      \begin{enumerate}
      \item $w(\neg p) = 1$,
      \item $l_i \in X_I$ or $\neg l_i \in X_I$ for all $i = 1, \dots, n$,
        \label{condition:equivalence1}
      \item and $\{ c \in \phi \mid p \in c \text{ or } \neg p \in c \} =
        \left\{p \lor \bigvee_{i=1}^n \neg l_i \right\} \cup \{ l_i \lor \neg p
        \mid i = 1, \dots, n \}$; \label{condition:equivalence2}
      \end{enumerate}
    \item or for all parameter variables $p \in X_P$, \label{condition:bklm16}
      \begin{enumerate}
      \item $w(p) + w(\neg p) = 1$,
      \item for any clause $c \in \phi$, $|c \cap X_P| \le 1$,
      \item there is no clause $c \in \phi$ such that $\neg p \in c$,
      \item if $\{ p \} \in \phi$, then there is no clause $c \in \phi$ such
        that $c \ne \{ p \}$ and $p \in c$, \label{cond:just_parameter}
        % 'prime implicants are logically disjoint'
      \item and for any $c, d \in \phi$ such that $c \ne d$, $p \in c$ and $p
        \in d$, $\bigwedge_{l \in c \setminus \{ p \}} \neg l \land \bigwedge_{l
          \in d \setminus \{ p \}} \neg l$ is false. \label{cond:disjoint}
      \end{enumerate}
    \end{enumerate}
  \end{enumerate}
\end{theorem}
\begin{proof}
  By \cref{prop:equivalence},
  \begin{equation}
    \left(\left\{[c]_0^1 \;\middle|\; c \in \phi\right\} \cup \left\{[x]_{w(\neg
          x)}^{w(x)} \;\middle|\; x \in X_I \cup X_P\right\}, X_I \cup X_P,
      1\right) \label{eq:new_wmc2}
  \end{equation}
  is a PBP instance with the same answer as the given WMC instance. By
  \cref{def:new_wmc}, its answer is
  \begin{equation} \label{eq:answer}
    \left(\exists_{X_I \cup X_P} \left( \prod_{c \in \phi} [c]_0^1 \right) \prod_{x \in X_I \cup X_P} [x]_{w(\neg x)}^{w(x)} \right)(\emptyset)
  \end{equation}
  Since both \cref{condition:d02,condition:bklm16} ensure that each clause in
  $\phi$ has at most one parameter variable, we can partition $\phi$ into
  $\phi_* \coloneqq \{c \in \phi \mid \mathtt{Vars}(c) \cap X_P = \emptyset \}$
  and $\phi_p \coloneqq \{ c \in \phi \mid \mathtt{Vars}(c) \cap X_P = \{ p \}
  \}$ for all $p \in X_P$. We can then use \cref{thm:early} to reorder
  \eqref{eq:answer} into
  \[
    \left(\exists_{X_I} \left( \prod_{x \in X_I} [x]_{w(\neg x)}^{w(x)} \right)
      \left( \prod_{c \in \phi_*} [c]_0^1 \right) \prod_{p \in X_P} \exists_p
      [p]_{w(\neg p)}^{w(p)} \prod_{c \in \phi_p} [c]_0^1 \right)(\emptyset).
  \]

  Let us first consider how the unfinished WMC instance $(F, X_I, \omega)$ after
  the loop on \crefrange{line:foreach1start}{line:foreach1end} differs from
  \eqref{eq:new_wmc2}. Note that \cref{alg:transformation} leaves each $c \in
  \phi_*$ unchanged, i.e., adds $[c]_0^1$ to $F$. We can then fix an arbitrary
  $p \in X_P$ and let $F_p$ be the set of functions added to $F$ as a
  replacement of $\phi_p$. It is sufficient to show that
  \begin{equation} \label{eq:to_show}
    \omega \prod_{f \in F_p} f = \exists_p [p]_{w(\neg p)}^{w(p)} \prod_{c \in \phi_p} [c]_0^1.
  \end{equation}
  Note that under \cref{condition:d02},
  \[
    \bigwedge_{c \in \phi_p} c \equiv p \Leftrightarrow \bigwedge_{i=1}^n l_i
  \]
  for some family of indicator variable literals $(l_i)_{i=1}^n$. Thus,
  \[
    \exists_p [p]_{w(\neg p)}^{w(p)} \prod_{c \in \phi_p} [c]_0^1 = \exists_p
    [p]_1^{w(p)} \left[ p \Leftrightarrow \bigwedge_{i=1}^n l_i \right]_0^1.
  \]
  If $w(p) = 1$, then
  \begin{equation} \label{eq:bigsums}
    \exists_p [p]_1^{w(p)} \left[ p \Leftrightarrow \bigwedge_{i=1}^n l_i
    \right]_0^1 = \exists_p \left[ p \Leftrightarrow \bigwedge_{i=1}^n l_i
    \right]_0^1 = \left.\left[ p \Leftrightarrow \bigwedge_{i=1}^n l_i
    \right]_0^1\right|_{p=1} + \left.\left[ p \Leftrightarrow \bigwedge_{i=1}^n
      l_i \right]_0^1\right|_{p=0}.
  \end{equation}
  Since for any input, $\bigwedge_{i=1}^n l_i$ is either true or false, exactly
  one of the two summands in \cref{eq:bigsums} will be equal to one, and the
  other will be equal to zero, and so
  \[
    \left.\left[ p \Leftrightarrow \bigwedge_{i=1}^n l_i
      \right]_0^1\right|_{p=1} + \left.\left[ p \Leftrightarrow \bigwedge_{i=1}^n
        l_i \right]_0^1\right|_{p=0} = 1,
  \]
  where $1$ is a pseudo-Boolean function that always returns one. On the other
  side of \cref{eq:to_show}, since $F_p = \emptyset$, and $\omega$ is unchanged,
  we get $\omega\prod_{f \in F_p} f = 1$, and so \cref{eq:to_show} is satisfied
  under \cref{condition:d02} when $w(p) = 1$.

  If $w(p) \ne 1$, then
  \[
    F_p = \left\{ \left[ \bigwedge_{i = 1}^n l_i \right]_1^{w(p)} \right\},
  \]
  and $\omega = 1$, and so we want to show that
  \[
    \left[ \bigwedge_{i = 1}^n l_i \right]_1^{w(p)} = \exists_p [p]_1^{w(p)}
    \left[ p \Leftrightarrow \bigwedge_{i=1}^n l_i \right]_0^1,
  \]
  and indeed
  \begin{align*}
    \exists_p [p]_1^{w(p)} \left[ p \Leftrightarrow \bigwedge_{i=1}^n l_i \right]_0^1 &= \left.\left( [p]_1^{w(p)} \left[ p \Leftrightarrow \bigwedge_{i=1}^n l_i \right]_0^1 \right)\right|_{p=1} + \left.\left([p]_1^{w(p)} \left[ p \Leftrightarrow \bigwedge_{i=1}^n l_i \right]_0^1 \right)\right|_{p=0} \\
                                                                                      &= w(p) \cdot \left[ \bigwedge_{i=1}^n l_i \right]_0^1 + \left[ \bigwedge_{i=1}^n l_i \right]_1^0 = \left[ \bigwedge_{i=1}^n l_i \right]_1^{w(p)}.
  \end{align*}
  This finishes the proof of the correctness of the first `foreach' loop under
  \cref{condition:d02}.

  Now let us assume \cref{condition:bklm16}. We still want to prove
  \cref{eq:to_show}. If $w(p) = 1$, then $F_p = \emptyset$, and $\omega = 1$,
  and so the left-hand side of \cref{eq:to_show} is equal to one. Then the
  right-hand side is
  \[
    \exists_p [p]_0^1 \prod_{c \in \phi_p} [c]_0^1 = \exists_p \left[ p \land
      \bigwedge_{c \in \phi_p} c \right]_0^1 = \exists_p [p]_0^1 = 0 + 1 = 1
  \]
  since $p \in c$ for every clause $c \in \phi_p$.

  If $w(p) \ne 1$, and $\{ p \} \in \phi_p$, then, by
  \cref{cond:just_parameter}, $\phi_p = \{ \{ p \} \}$, and
  \cref{alg:transformation} produces $F_p = \emptyset$ and $\omega = w(p)$, and
  so
  \[
    \exists_p [p]_{w(\neg p)}^{w(p)} [p]_0^1 = \exists_p [p]^{w(p)}_0 = w(p) =
    \omega \prod_{f \in F_p} f.
  \]
  The only remaining case is when $w(p) \ne 1$ and $\{ p \} \not \in \phi_p$.
  Then $\omega = 1$, and
  \[
    F_p = \left\{ \left[\bigwedge_{l \in c \setminus \{ p \}} \neg
        l\right]_1^{w(p)} \;\middle|\; c \in \phi_p \right\},
  \]
  so need to show that
  \[
    \prod_{c \in \phi_p} \left[\bigwedge_{l \in c \setminus \{ p \}} \neg
      l\right]_1^{w(p)} = \exists_p [p]_{1-w(p)}^{w(p)} \prod_{c \in \phi_p}
    [c]_0^1.
  \]
  We can rearrange the right-hand side as
  \begin{align*}
    \exists_p [p]_{1-w(p)}^{w(p)} \prod_{c \in \phi_p} [c]_0^1 &= \exists_p [p]_{1-w(p)}^{w(p)} \left[\bigwedge_{c \in \phi_p} c\right]_0^1 = \exists_p [p]_{1-w(p)}^{w(p)} \left[ p \lor \bigwedge_{c \in \phi_p} c \setminus \{ p \} \right]_0^1 \\
                                                               &= w(p) + (1-w(p)) \left[ \bigwedge_{c \in \phi_p} c \setminus \{ p \} \right]_0^1 = w(p) + \left[ \bigwedge_{c \in \phi_p} c \setminus \{ p \} \right]_0^{1-w(p)} \\
                                                               &= \left[ \bigwedge_{c \in \phi_p} c \setminus \{ p \} \right]_{w(p)}^1 = \left[ \neg \bigwedge_{c \in \phi_p} c \setminus \{ p \} \right]_1^{w(p)} = \left[ \bigvee_{c \in \phi_p} \neg(c \setminus \{ p \}) \right]_1^{w(p)} \\
                                                               &= \left[ \bigvee_{c \in \phi_p} \neg \bigvee_{l \in c \setminus \{ p \}} l \right]_1^{w(p)} = \left[ \bigvee_{c \in \phi_p} \bigwedge_{l \in c \setminus \{ p \}} \neg l \right]_1^{w(p)}.
  \end{align*}
   By \cref{cond:disjoint}, $\bigwedge_{l \in c \setminus \{ p \}} \neg l$ can
   be true for at most one $c \in \phi_p$, and so
   \[
     \left[ \bigvee_{c \in \phi_p} \bigwedge_{l \in c \setminus \{ p \}} \neg l
     \right]_1^{w(p)} = \prod_{c \in \phi_p} \left[ \bigwedge_{l \in c \setminus
         \{ p \}} \neg l \right]_1^{w(p)}
   \]
   which is exactly what we needed to show. This ends the proof that the
   first loop of \cref{alg:transformation} preserves the answer under both
   \cref{condition:d02} and \cref{condition:bklm16}. Finally, the loop on
   \crefrange{line:foreach2start}{line:foreach2end} of \cref{alg:transformation}
   replaces $[v]_1^p[\neg v]_1^q$ with $[v]_q^p$ (for some $v \in X_I$ and $p, q
   \in \mathbb{R}$), but, of course,
   \[
     [v]_1^p[\neg v]_1^q = [v]_1^p[v]_q^1 = [v]_q^p,
   \]
   i.e., the answer is unchanged.
\end{proof}

\section{Experimental Results}

\paragraph{Notes.}
\begin{itemize}
\item Apparently, the \textsc{DPMC} paper \cite{DBLP:conf/cp/DudekPV20} already
  shows that taking the first offered decomposition tree is best.
\item Processors:
  \begin{itemize}
  \item Intel(R) Xeon(R) Gold 6138 CPU @ 2.00GHz
  \item Intel(R) Xeon(R) CPU E5-2630 v3 @ 2.40GHz
  \item Intel(R) Xeon(R) CPU E7-4820 v2 @ 2.00GHz
  \end{itemize}
\end{itemize}

\begin{figure}[t]
  \centering
  \input{cumulative.tex}%
  \caption{TODO}
  \label{fig:cumulative}
\end{figure}

\section{Conclusions}

\paragraph{Notes.}
\begin{itemize}
\item This just says that $p$ is equivalent to a conjunction.
\item The first group of conditions applies to \texttt{d02}, while the second
  group applies to \texttt{bklm16}.
\item For \texttt{cd05} and \texttt{cd06}, condition $2bi$ should be replaced
  with $w(\neg p) = 1$.
\item Benefits of having this proof in the paper:
  \begin{itemize}
  \item It puts all encodings on a common ground.
  \item It illustrates the convenience of our notation for reasoning about
    (certain types of) pseudo-Boolean functions.
  \item It's too big and too important to be left for the appendix.
  \end{itemize}
\end{itemize}

\paragraph{TODO}
\begin{itemize}
\item Do I need to formally consider extending a pseudo-Boolean function to a
  bigger domain?
\item check if each condition is actually used. Maybe turn this into a paragraph
  that gives an overview of the proof.
\item condition 1 is necessary in both cases because we're ignoring the weights
  of indicator variables (explicitly acknowledge this)
\item add the \texttt{cd05}/\texttt{cd06} correctness theorem
\end{itemize}

\bibliographystyle{splncs04}
\bibliography{paper}

\end{document}
