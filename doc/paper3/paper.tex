\documentclass{article}
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[UKenglish]{babel}
\usepackage[capitalise]{cleveref}
\usepackage{fullpage}
\usepackage[utf8]{inputenc}
\usepackage[UKenglish]{isodate}
\usepackage{mathtools}
\usepackage[backgroundcolor=lightgray]{todonotes}

\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{conjecture}{Conjecture}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\theoremstyle{remark}
\newtheorem*{remark}{Remark}

\crefname{enumii}{Condition}{Conditions}

\title{Weighted Model Counting Without Parameter Variables}

\begin{document}

\maketitle

\section{Introduction}

\paragraph{Notation.} For any propositional formula $\phi$ and $p, q \in
\mathbb{R}$, let $[\phi]^p_q\colon 2^X \to \mathbb{R}$ be a
pseudo-Boolean function defined as
\[
  [\phi]^p_q(Y) \coloneqq
  \begin{cases}
    p & \text{if } Y \models \phi \\
    q & \text{otherwise}
  \end{cases}
\]
for any $Y \subseteq X$.

% NOTE: weights on literals other than the positive literals that correspond to
% variables in $X_P$ are redundant as they either are equal to one or duplicate
% an already-defined weight.
\begin{definition}[old WMC instance]
  An \emph{old WMC instance} is a tuple $(\phi, X_I, X_P, w)$, where $X_I$ is
  the set of indicator variables, $X_P$ is the set of parameter variables (with
  $X_I \cap X_P = \emptyset$), $\phi$ is a propositional formula in CNF over
  $X_I \cup X_P$, and $w\colon X_I \cup X_P \cup \{\neg x \mid x \in X_I \cup
  X_P\} \to \mathbb{R}$ is the weight function. The \emph{answer} of the
  instance is $\sum_{Y \models \phi} \prod_{Y \models l} w(l)$.
\end{definition} % TODO: add a citation for this.

\begin{remark}
  Encodings such as \texttt{cd05} and \texttt{cd06} are \emph{not} WMC
  encodings. Instead, they encode Bayesian network inference into instances of
  the \emph{minimum-cardinality} WMC problem, where the answer is defined to be
  $\sum_{Y \models \phi\text{, }|Y| = k} \prod_{Y \models l}
  w(l)$, where $k = \min_{Y \models \phi\text{, }Y \ne \emptyset}
  |Y|$, if $k$ exists, otherwise the answer is zero. This additional
  condition on model cardinality becomes necessary because these encodings
  eliminate clauses of the form $p \Rightarrow i$, where $p \in X_P$ is a
  parameter variable, and $i \in X_I$ is an indicator variable. Nonetheless, our
  transformation algorithm still works on such encodings, although the
  experimental results are discouraging because they use approximately twice as
  many indicator variables. For instance, each binary variable of a Bayesian
  network is encoded using two indicator variables while one would suffice.
\end{remark} % TODO: perhaps add this claim as a corollary

\begin{definition}[new WMC instance] \label{def:new_wmc}
  A \emph{new WMC instance} is a tuple $(F, X, \omega)$, where $X$ is the set of
  variables, $F$ is a set of pseudo-Boolean functions $2^X \to \mathbb{R}$, and
  $\omega \in \mathbb{R}$ is the scaling factor. The \emph{answer} of the
  instance is $\omega \cdot \left(\exists_X\prod_{f \in F}f\right)(\emptyset)$.
\end{definition}

\paragraph{References.}
\begin{itemize}
\item Related work without publicly available implementations:
  \begin{itemize}
  \item direct compilation to SDDs \cite{DBLP:conf/ecsqaru/ChoiKD13}
  \item direct compilation to PSDDs, also eliminating parameter variables (a thesis)
  \item maybe two more papers
  \end{itemize}
\end{itemize}

\paragraph{Notes.}
\begin{itemize}
\item Apparently, the \textsc{DPMC} paper already shows that taking the first
  offered decomposition tree is best.
\item It is already well-known that WMC is FPT.
\end{itemize}

\section{Parameter Variable Elimination}

\paragraph{Notes.}
\begin{itemize}
\item Let $X_P$ be the set of parameter variable and $X_I$ be the set of
  indicator variables.
\item Parameter variables are either taken from the LMAP file (for encodings
  produced by Ace) or assumed to be the variables that have both weights equal
  to 1.
\item If a parameter variable in a clause is `negated', we can ignore the
  clause. We assume that there are no clauses with more than one instance of
  parameter variables.
\item The second \textbf{foreach} loop can be performed in constant time by
  representing $\phi'$ as a list and assuming that the two 'clauses' are
  adjacent in that list (and incorporating it into the first loop).
\item The $d$ map is constructed in $\mathcal{O}(|X_P|\log|X_P|)$ time (we want
  to use a data structure based on binary search trees rather than hashing).
\item \texttt{rename} can be implemented in $\mathcal{O}(\log |X_P|)$ time.
\item This may look like preprocessing, but all the transformations are local
  and thus can be incorporated into an encoding algorithm with no slowdown. In
  fact, if anything, the resulting algorithm would be slightly faster, as it
  would have less data to output.
\end{itemize}

\begin{algorithm}
  \caption{WMC instance transformation}
  \label{alg:transformation}
  \SetKwFunction{rename}{rename}
  \SetKwProg{Fn}{Function}{:}{}
  \KwData{an (old-format) WMC instance $(\phi, X_I, X_P, w)$}
  \KwResult{a (new-format) WMC instance $(F, X, \omega)$}
  $F \gets \emptyset$\;
  $\omega \gets 1$\;
  let $d\colon X_P \to \mathbb{N}$ be defined as $p \mapsto |\{ o \in X_P \mid o
  \le p \}|$\;
  \ForEach{clause $c \in \phi$\label{line:foreach1start}}{
    \uIf{$c \cap X_P = \{ p \}$ for some $p$ \textnormal{\textbf{and}} $w(p) \ne
      1$}{
      \uIf{$|c| = 1$}{$\omega \gets \omega \times w(p)$\;}
      \Else{
        $F \gets F \cup \left\{ \left[ \bigwedge_{l \in c \setminus
              \{p\}} \neg l \right]^{w(p)}_1 \right\}$\;
      }
    }
    \ElseIf{$\{p \mid \neg p \in c\} \cap X_P  = \emptyset$}{
      $F \gets F \cup \{ [c]^1_0 \}$\; \label{line:foreach1end}
    }
  }
  \ForEach{indicator variable $v \in X_I$}{
    \If{$\{[v]_1^p, [\neg v]_1^q\} \subseteq F$ for some $p$ and $q$}{
      $F \gets F \setminus \{ [v]_1^p, [\neg v]_1^q \} \cup \{ [v]_q^p
      \}$\;
    }
  }
  replace every variable $v$ in $F$ with $\rename{$v$}$\;
  \Return{$(F, X_I, \omega)$}\;
  \Fn{\rename{$v$}}{
    $S \gets \{u \in X_P \mid u \le v\}$\;
    \lIf{$S = \emptyset$}{\Return{$v$}}
    \Return{$v - d(\max S)$}\;
  }
\end{algorithm}

\subsection{Correctness}

\begin{theorem}[Early Projection
  \cite{DBLP:conf/aaai/DudekPV20,DBLP:conf/cp/DudekPV20},
  verbatim] \label{thm:early}
  Let $X$ and $Y$ be sets of variables. For all functions $f\colon 2^X \to
  \mathbb{R}$ and $g\colon 2^Y \to \mathbb{R}$, if $x \in X \setminus Y$, then
  $\exists_x (f \cdot g) = (\exists_x f) \cdot g$.
\end{theorem}
% TODO: mention that formulas, clauses, and models are all treated as sets

\begin{lemma} \label{lemma:sum}
  For any pseudo-Boolean function $f\colon 2^X \to \mathbb{R}$, $(\exists_X
  f)(\emptyset) = \sum_{Y \subseteq X} f(Y)$.
\end{lemma}
\begin{proof}
  For base case, let $X = \{x\}$. Then
  \[
    \exists_xf = f|_{x=1} + f|_{x=0},
  \]
  by \cref{def:projection} and so
  \[
    (\exists_xf)(\emptyset) = f|_{x=1}(\emptyset) + f|_{x=0}(\emptyset)
  \]
  by \cref{def:operations}. Then
  \[
    f|_{x=1}(\emptyset) = f(\{x\}), \quad \text{and} \quad f|_{x=0}(\emptyset) =
    f(\emptyset)
  \]
  by \cref{def:restriction}. It follows that
  \[
    (\exists_xf)(\emptyset) = f(\{x\}) + f(\emptyset) = \sum_{Y \subseteq \{x\}}
    f(Y)
  \]
  as required. This easily extends to $|X| > 1$ by the definition of projection
  on sets of variables. % TODO: once I've defined it, add a reference here.
\end{proof}
% TODO: must mention that operations like +/x are commutative, associative, etc.

% NOTE: mention that this is similar (but not equal) to the DPMC/ADDMC result
\begin{proposition} \label{prop:equivalence}
  Let $(\phi, X_I, X_P, w)$ be an old WMC instance. Then
  \begin{equation}
  \left(\left\{[c]_0^1 \;\middle|\; c \in \phi\right\} \cup \left\{[x]_{w(\neg
        x)}^{w(x)} \;\middle|\; x \in X_I \cup X_P\right\}, X_I \cup X_P,
    1\right) \label{eq:new_wmc}
  \end{equation}
  is a new WMC instance with the same answer.
\end{proposition}
\begin{proof}
  The answer of \cref{eq:new_wmc} is
  \begin{align*}
    \left(\exists_{X_I \cup X_P} \prod_{c \in \phi} [c]_0^1 \prod_{x \in X_I \cup X_P} [x]_{w(\neg x)}^{w(x)} \right)(\emptyset) &= \sum_{Y \subseteq X_I \cup X_P} \left(\prod_{c \in \phi} [c]_0^1 \prod_{x \in X_I \cup X_P} [x]_{w(\neg x)}^{w(x)}\right)(Y) \\
&= \sum_{Y \subseteq X_I \cup X_P} \underbrace{\left(\prod_{c \in \phi} [c]_0^1\right)}_f(Y) \underbrace{\left(\prod_{x \in X_I \cup X_P} [x]_{w(\neg x)}^{w(x)}\right)}_g(Y)
  \end{align*}
  by \cref{def:new_wmc,lemma:sum,def:operations}. Note that
  \[
    f(Y) =
    \begin{cases}
      1 & \text{if } Y \models \phi, \\
      0 & \text{otherwise},
    \end{cases}
    \quad
    \text{and}
    \quad
    g(Y) = \prod_{Y \models l} w(l),
  \]
  which means that
  \[
    \sum_{Y \subseteq X_I \cup X_P} f(Y)g(Y) = \sum_{Y \models \phi} \prod_{Y
      \models l} w(l)
  \]
  as required.
\end{proof}

\begin{theorem}[Correctness]
  \Cref{alg:transformation}, when given an old WMC instance $(\phi, X_I, X_P,
  w)$, returns a new WMC instance with the same answer, provided the following
  conditions are satisfied:
  \begin{enumerate}
  \item for all indicator variables $i \in X_I$, $w(i) = w(\neg i) = 1$,
  \item and either
    \begin{enumerate}
    \item for all parameter variables $p \in X_P$, there is a non-empty family
      of literals $(l_i)_{i=1}^n$ such that \label{condition:d02}
      \begin{enumerate}
      \item $w(\neg p) = 1$,
      \item $l_i \in X_I$ or $\neg l_i \in X_I$ for all $i = 1, \dots, n$,
        \label{condition:equivalence1}
      \item and $\{ c \in \phi \mid p \in c \text{ or } \neg p \in c \} =
        \left\{p \lor \bigvee_{i=1}^n \neg l_i \right\} \cup \{ l_i \lor \neg p
        \mid i = 1, \dots, n \}$; \label{condition:equivalence2}
      \end{enumerate}
    \item or for all parameter variables $p \in X_P$, \label{condition:bklm16}
      \begin{enumerate}
      \item $w(p) + w(\neg p) = 1$,
      \item for any clause $c \in \phi$, $|c \cap X_P| \le 1$,
      \item there is no clause $c \in \phi$ such that $\neg p \in c$,
      \item and for any pair of clauses $c, d \in \phi$ such that $c \ne d$, $p
        \in c$ and $p \in d$, $\mathtt{Vars}(c) \cap \mathtt{Vars}(d) = \{ p
        \}$.
      \end{enumerate}
    \end{enumerate}
  \end{enumerate}
\end{theorem} % TODO: add parentheses around products
% TODO: maybe give a name to (2) since it's wrong to call it an equation
\begin{proof} % TODO: check if each condition is actually used
  % TODO: start here: consider how the transformation changes the 'normal form'.
  % We will show that every iteration keeps the answer the same as in the normal form.
  By \cref{prop:equivalence},
  \begin{equation}
    \left(\left\{[c]_0^1 \;\middle|\; c \in \phi\right\} \cup \left\{[x]_{w(\neg
          x)}^{w(x)} \;\middle|\; x \in X_I \cup X_P\right\}, X_I \cup X_P,
      1\right) \label{eq:new_wmc}
  \end{equation}
  is a new WMC instance with the same answer as the given old WMC instance. By
  \cref{def:new_wmc}, its answer is
  \begin{equation} \label{eq:answer}
    \left(\exists_{X_I \cup X_P} \prod_{c \in \phi} [c]_0^1 \prod_{x \in X_I
        \cup X_P} [x]_{w(\neg x)}^{w(x)} \right)(\emptyset)
  \end{equation}
  Since both \cref{condition:d02,condition:bklm16} ensure that each clause in
  $\phi$ has at most one parameter variable, we can partition $\phi$ into
  $\phi_* \coloneqq \{c \in \phi \mid \mathtt{Vars}(c) \cap X_P = \emptyset \}$
  and $\phi_p \coloneqq \{ c \in \phi \mid \mathtt{Vars}(c) \cap X_P = \{ p \}
  \}$ for all $p \in X_P$. We can then use \cref{thm:early} to reorder
  \cref{eq:answer} into
  \[
    \left(\exists_{X_I} \left( \prod_{x \in X_I} [x]_{w(\neg x)}^{w(x)} \right)
      \left( \prod_{c \in \phi_*} [c]_0^1 \right) \prod_{p \in X_P} \exists_p
      [p]_{w(\neg p)}^{w(p)} \prod_{c \in \phi_p} [c]_0^1 \right)(\emptyset).
  \]

  Let us first consider how the unfinished WMC instance $(F, X_I, \omega)$ after
  the loop on \crefrange{line:foreach1start}{line:foreach1end} differs from
  \cref{eq:new_wmc}. Note that \cref{alg:transformation} leaves each $c \in
  \phi_*$ unchanged, i.e., adds $[c]_0^1$ to $F$. We can then fix an arbitrary
  $p \in X_P$ and let $F_p$ be the set of functions added to $F$ as a
  replacement of $\phi_p$. It is sufficient to show that
  \begin{equation} \label{eq:to_show}
    \omega \prod_{f \in F_p} f = \exists_p [p]_{w(\neg p)}^{w(p)} \prod_{c \in \phi_p} [c]_0^1.
  \end{equation}
  Note that under \cref{condition:d02},
  \[
    \bigwedge_{c \in \phi_p} c \equiv p \Leftrightarrow \bigwedge_{i=1}^n l_i
  \]
  for some family of indicator variable literals $(l_i)_{i=1}^n$. Thus,
  \[
    \exists_p [p]_{w(\neg p)}^{w(p)} \prod_{c \in \phi_p} [c]_0^1 = \exists_p
    [p]_1^{w(p)} \left[ p \Leftrightarrow \bigwedge_{i=1}^n l_i \right]_0^1.
  \]
  If $w(p) = 1$, then
  \begin{equation} \label{eq:bigsums}
    \exists_p [p]_1^{w(p)} \left[ p \Leftrightarrow \bigwedge_{i=1}^n l_i
    \right]_0^1 = \exists_p \left[ p \Leftrightarrow \bigwedge_{i=1}^n l_i
    \right]_0^1 = \left.\left[ p \Leftrightarrow \bigwedge_{i=1}^n l_i
    \right]_0^1\right|_{p=1} + \left.\left[ p \Leftrightarrow \bigwedge_{i=1}^n
      l_i \right]_0^1\right|_{p=0}
  \end{equation}
  by \cref{def:projection}. Since for any input, $\bigwedge_{i=1}^n l_i$ is
  either true or false, exactly one of the two summands in \cref{eq:bigsums}
  will be equal to one, and the other will be equal to zero, and so
  \[
    \left.\left[ p \Leftrightarrow \bigwedge_{i=1}^n l_i
      \right]_0^1\right|_{p=1} + \left.\left[ p \Leftrightarrow \bigwedge_{i=1}^n
        l_i \right]_0^1\right|_{p=0} = 1,
  \]
  where $1$ is a pseudo-Boolean function that always returns one. On the other
  side of \cref{eq:to_show}, since $F_p = \emptyset$, and $\omega$ is unchanged,
  we get $\omega\prod_{f \in F_p} f = 1$, and so \cref{eq:to_show} is satisfied
  under \cref{condition:d02} when $w(p) = 1$.

  If $w(p) \ne 1$, then
  \[
    F_p = \left\{ \left[ \bigwedge_{i = 1}^n l_i \right]_1^{w(p)} \right\},
  \]
  and so we want to show that
  \[
    \left[ \bigwedge_{i = 1}^n l_i \right]_1^{w(p)} = \exists_p [p]_1^{w(p)}
    \left[ p \Leftrightarrow \bigwedge_{i=1}^n l_i \right]_0^1.
  \]
  By \cref{def:projection},
  \begin{align*}
    \exists_p [p]_1^{w(p)} \left[ p \Leftrightarrow \bigwedge_{i=1}^n l_i \right]_0^1 &= \left.\left( [p]_1^{w(p)} \left[ p \Leftrightarrow \bigwedge_{i=1}^n l_i \right]_0^1 \right)\right|_{p=1} + \left.\left([p]_1^{w(p)} \left[ p \Leftrightarrow \bigwedge_{i=1}^n l_i \right]_0^1 \right)\right|_{p=0} \\
                                                                                      &= w(p) \cdot \left[ \bigwedge_{i=1}^n l_i \right]_0^1 + \left[ \bigwedge_{i=1}^n l_i \right]_1^0 = \left[ \bigwedge_{i=1}^n l_i \right]_1^{w(p)}
  \end{align*}
  as required. This finishes the proof of the correctness of the first `foreach'
  loop under \cref{condition:d02}.

  Now let us assume \cref{condition:bklm16}. We still want to prove
  \cref{eq:to_show}.
\end{proof}
% TODO: now consider the second for loop
% TODO: condition 1 is necessary in both cases because we're ignore the weights
% of indicator variables

\paragraph{Notes.}
\begin{itemize}
\item This just says that $p$ is equivalent to a conjunction.
\item The first group of conditions applies to \texttt{d02}, while the second
  group applies to \texttt{bklm16}.
\item For \texttt{cd05} and \texttt{cd06}, condition $2bi$ should be replaced
  with $w(\neg p) = 1$.
\end{itemize}

\section{Parameterised Complexity of \textsc{DPMC}}

\paragraph{Notes.}
\begin{itemize}
\item Summary of results
  \begin{itemize}
  \item We establish \textsc{DPMC} inference as fixed-parameter tractable.
  \item We experimentally show that \textsc{DPMC} is best on low-to-moderate
    treewidth instances, and cd06+c2d overtakes on higher treewidth instances.
  \end{itemize}
\item By \textsc{DPMC}, we always mean DMC+lg.
\item The constant is inspired by the \texttt{bklm16} encoding.
\end{itemize}

\paragraph{TODO}
\begin{itemize}
\item Do I need to formally consider extending a pseudo-Boolean function to a
  bigger domain?
\item Introduce all the notation surrounding graphs ($\mathcal{V}$,
  $\mathcal{E}$ $\mathcal{L}$, $\mathcal{C}$, etc.) (and be consistent with its
  usage) and formulas (variable, literal, clause, CNF, etc.)
\item Use \cref{thm:connection} to show the connection between primal treewidth
  and the width of the PJT (linking the complexity of BN inference with the DPMC
  complexity).
\item Come up with better names for old/new WMC instances.
\item Define:
  \begin{itemize}
  \item scalar operations on ADDs,
  \item an ADD as a DAG,
  \item What does it mean for an ADD to `have' variables? Maybe refer to
    pseudo-Boolean function sensitivity.
  \item primal graph of a CNF formula (a.k.a.
    Gaifman/(variable) interaction/connectivity/clique/representing graph),
  \item Bayesian network (I already have a definition of these last two),
  \item moralisation of a Bayesian network (or of any DAG),
  \item projection of a set of variables.
  \end{itemize}
\end{itemize}

\begin{lemma} \label{lemma:add_size}
  An ADD with $n$ variables has $\mathcal{O}(2^n)$ nodes.
\end{lemma}
\begin{proof}
  An ADD with $n$ variables can be, at most, a complete binary tree of height
  $n+1$ (as measured by the number of vertices). It would then have $2^0 + 2^1 +
  \dots + 2^n = 2^{n+1} = \mathcal{O}(2^n)$ nodes.
\end{proof}

\begin{lemma} \label{lemma:clause_time}
  Let $\phi$ be a conjunction of $n$ literals. Then the ADD representation of
  $[\phi]^p_q$ can be constructed in $\mathcal{O}(2^n)$ time for any $p, q \in
  \mathbb{R}$ such that $p \ne q$.
\end{lemma}
\begin{proof}
  The ADD representation of $\phi$ itself can be constructed with a sequence of
  $n-1$ calls to \texttt{apply} with one of the two operands in each call always
  a literal. The number of variables in the other operand then follows the
  sequence $1, 2, 3, \dots, n-1$. By \cref{lemma:add_size}, the numbers of nodes
  in the ADD representations of these operands is then $\mathcal{O}(2^1),
  \mathcal{O}(2^2), \dots, \mathcal{O}(2^{n-1})$. Since one of the operands is
  of constant size, the overall time complexity of all calls to \texttt{apply}
  is then
  \[
    \mathcal{O}(2^1) + \mathcal{O}(2^2) + \dots + \mathcal{O}(2^{n-1}) =
    \mathcal{O}(2^n).
  \]

  Let $\alpha$ be the ADD representation of $\phi$. Then the ADD representation
  of $[\phi]_q^p$ is $(p-q)\alpha + q$. As scalar operations can obviously be
  implemented in linear time, the overall complexity remains $\mathcal{O}(2^n)$.
\end{proof}

\begin{theorem}[\cite{DBLP:conf/ecai/KwisthoutBG10}, rephrased]
  BN Inference (for all algorithms that accept arbitrary instances) has a lower
  bound that's linear in the size of the BN and exponential in the treewidth of
  its moralisation (provide the exact formula).
\end{theorem}

\begin{definition}[\cite{DBLP:conf/cp/DudekPV20}, with some changes]
  Let $X$ be a set of Boolean variables, and $F$ be a set of pseudo-Boolean
  functions $2^X \to \mathbb{R}$. A \emph{project-join tree} (PJT) of $F$ is a
  tuple $(T, r, \gamma, \pi)$ where:
  \begin{itemize}
  \item $T$ is a tree with root $r \in \mathcal{V}(T)$,
  \item $\gamma\colon \mathcal{L}(T) \to F$ is a bijection between the leaves of
    $T$ and the pseudo-Boolean functions in $F$, and
  \item $\pi\colon \mathcal{V}(T) \setminus \mathcal{L}(T) \to 2^X$ is a
    labelling function on internal nodes.
  \end{itemize}
  Moreover, $(T, r, \gamma, \pi)$ must satisfy the following two properties:
  \begin{enumerate}
  \item $\{\pi(n) : n \in \mathcal{V}(T) \setminus \mathcal{L}(T)\}$ is a
    partition of $X$, and
  \item for each internal node $n \in \mathcal{V}(T) \setminus \mathcal{L}(T)$,
    variable $x \in \pi(n)$, and `clause' $c \in F$ such that $x$
    appears in $c$, the leaf node $\gamma^{-1}(c)$ must be a descendant of $n$
    in $T$.
  \end{enumerate}
\end{definition}

\begin{definition}[\cite{DBLP:conf/cp/DudekPV20}] \label{def:size}
  \[
    \mathtt{Vars}(n) \coloneqq
    \begin{cases}
      \mathtt{Vars}(\gamma(n)) & \text{if } n \in \mathcal{L}(T) \\
      \left( \bigcup_{o \in \mathcal{C}(n)} \mathtt{Vars}(o) \right) \setminus
      \pi(n) & \text{if } n \not\in \mathcal{L}(T).
    \end{cases}
  \]
  \[
    \mathtt{size}(n) \coloneqq
    \begin{cases}
      |\mathtt{Vars}(n)| & \text{if } n \in \mathcal{L}(T) \\
      |\mathtt{Vars}(n) \cup \pi(n)| & \text{if } n \not\in \mathcal{L}(T).
    \end{cases}
  \]
  (Note that $\mathtt{size}(n)$ is the number of variables that can appear
  during the computation of $\delta(n)$ (excluding recursive calls).)
  The \emph{width} of a PJT $(T, r, \gamma, \pi)$ is
  $\mathtt{width}(T) \coloneqq \max_{n \in \mathcal{V}(T)} \mathtt{size}(n)$.
\end{definition} % TODO: don't actually need this much notation.

\begin{theorem}[\cite{DBLP:conf/cp/DudekPV20}, rephrased, `ADD width is equal
  to the treewidth of the primal graph']
  Given a CNF formula $\phi$ with a tree decomposition of its primal graph of
  width $w$, Algorithm~2 (from \cite{DBLP:conf/cp/DudekPV20}) returns a
  PJT of $\phi$ of width at most $w+1$.
\end{theorem}

\begin{definition}[\cite{DBLP:journals/jct/RobertsonS84}, rephrased]
  A \emph{tree decomposition} of a graph $G$ is a pair $(T, \chi)$, where $T$ is
  a tree and $\chi\colon \mathcal{V}(T) \to 2^{\mathcal{V}(G)}$ is a labelling
  function, with the following properties:
  \begin{itemize}
  \item $\bigcup_{t \in \mathcal{V}(T)} \chi(t) = \mathcal{V}(G)$;
  \item for every edge $e \in \mathcal{E}(G)$, there exists $t \in
    \mathcal{V}(T)$ such that $e$ has both endpoints in $\chi(t)$;
  \item for all $t, t', t'' \in \mathcal{V}(T)$, if $t'$ is on the path between
    $t$ and $t''$, then $\chi(t) \cap \chi(t'') \subseteq \chi(t')$.
  \end{itemize}
  The \emph{width} of tree decomposition $(T, \chi)$ is $\max_{t \in
    \mathcal{V}(T)} |\chi(t)| - 1)$. The \emph{treewidth} of graph $G$ is the
  smallest $w$ such that $G$ has a tree decomposition of width $w$.
\end{definition}

\begin{definition} \label{def:operations}
  Let $f, g\colon 2^X \to \mathbb{R}$ be pseudo-Boolean functions. Operations
  such as addition and multiplication are defined pointwise as
  \[
    (f+g)(Y) \coloneqq f(Y)+g(Y), \quad \text{and} \quad (fg)(Y) \coloneqq
    f(Y)g(Y)
  \]
  for all $Y \subseteq X$.
\end{definition}

\begin{definition} \label{def:restriction}
  Let $f\colon 2^X \to \mathbb{R}$ be a pseudo-Boolean function, and $x \in X$.
  Then $f|_{x=0}, f|_{x=1}\colon 2^X \to \mathbb{R}$ are \emph{restrictions} of
  $f$ defined as
  \[
    f|_{x=0}(Y) \coloneqq f(Y \setminus \{x\}), \quad \text{and} \quad
    f|_{x=1}(Y) \coloneqq f(Y \cup \{x\})
  \]
  for all $Y \subseteq X$.
\end{definition}

\begin{definition} \label{def:projection}
  Let $X$ be a set. For any $x \in X$, \emph{projection} $\exists_x$ is an
  endomorphism $\exists_x\colon \mathbb{R}^{2^X} \to \mathbb{R}^{2^X}$ defined
  as
  \[
    \exists_xf \coloneqq f|_{x=1} + f|_{x=0}
  \]
  for any $f\colon 2^X \to \mathbb{R}$.
\end{definition}

\begin{lemma} \label{lemma:basic_ops}
  Let $f,g\colon 2^X \to \mathbb{R}$ be pseudo-Boolean functions represented by
  ADDs with $n$ and $m$ nodes, respectively, and $x \in X$. Then $f+g$ and $fg$
  can be computed in $\mathcal{O}(mn)$ time, and $\exists_xf$ can be computed in
  $\mathcal{O}(n^2)$ time.
\end{lemma}
\begin{proof}
  Addition and multiplication are implemented by \texttt{apply} algorithm which
  takes $\mathcal{O}(mn)$ time \cite{DBLP:journals/tc/Bryant86}. Projection
  consists of two restrictions and an addition by \cref{def:projection}. The
  computational complexity of restriction is dominated by the reduction
  operation that transforms a decision diagram into a minimal canonical form
  \cite{DBLP:journals/tc/Bryant86}. While the original reduction algorithm had a
  $\mathcal{O}(n \log n)$ complexity, caching can reduce it to $\mathcal{O}(n)$
  \cite{somenzi1998cudd}. Either way, the complexity of projection is still
  $\mathcal{O}(n^2)$.
\end{proof}

% NOTE: this is a rehash of equation (2) from the DPMC paper
\begin{definition} \label{def:abstraction}
  Let $(T, r, \gamma, \pi)$ be a PJT, and $X$ be the set of variables. The
  functionality of \textsc{DPMC} execution can be represented by $\delta(r)$,
  where $\delta\colon \mathcal{V}(T) \to \mathbb{R}^{2^X}$ is a recursive
  function defined as
  \begin{equation} \label{eq:execution}
    \delta(t) \coloneqq
    \begin{cases}
      \gamma(t) & \text{if } t \in \mathcal{L}(T) \\
      \exists_{\pi(t)} \prod_{u \in \mathcal{C}(t)} \delta(u) & \text{otherwise.}
    \end{cases}
  \end{equation}
  The range of $\delta(r)$ then contains a single real number, i.e., the answer.
\end{definition}

% TODO: will need to rephrase this to fit my context
\begin{theorem}[Theorem~4 in \cite{DBLP:conf/cp/DudekPV20}, almost
  verbatim] \label{thm:connection}
  Let $\phi$ be a propositional formula in CNF over a set $X$ of variables and
  $(S, \chi)$ be a tree decomposition of the primal graph of $\phi$ of width
  $w$. Then Algorithm~2 returns a PJT of $\phi$ of width at most $w+1$.
\end{theorem}

\begin{theorem}
  Let $(F, X, \omega)$ be a WMC instance, and $(T, r, \gamma, \pi)$ be its PJT
  of width $k$. Then \textsc{DPMC} execution is fixed-parameter tractable with
  respect to $k$. Specifically, \textsc{DPMC} execution time complexity is
  $\mathcal{O}(4^knm)$, where $n = |\mathcal{L}(T)| = |F|$, and $m = |X|$ is the
  number of variables.
\end{theorem}
\begin{proof}
  \begin{itemize}
  \item We consider the complexity of constructing ADD representations of the
    pseudo-Boolean functions in $F$ and the complexity of multiplication and
    projection operations throughout the recursive calls of $\delta$ in
    \cref{def:abstraction}.
  \item Let $t \in \mathcal{L}(T)$ be a leaf. Note that
    $|\mathtt{Vars}(\gamma(t))| \le k$ by \cref{def:size}. Assuming that clauses
    have no repeating variables, it takes $\mathcal{O}(2^k)$ time to construct
    $\delta(t)$ by \cref{lemma:clause_time} and $\mathcal{O}(2^kn)$ time to
    construct all leaves of the PJT.
  \item Now let $t \in \mathcal{V}(T) \setminus \mathcal{L}(T)$ be an internal
    vertex, in which case we perform $|\mathcal{C}(t)|-1$ multiplications and
    $|\pi(t)|$ projections. Note that $|\mathcal{C}(t)| \le |\mathcal{L}(T)| =
    n$, $|\pi(t)| \le k$, and the ADDs involved can have up to $k$ variables.
    This means that each ADD has $\mathcal{O}(2^k)$ nodes (regardless of whether
    it comes from $\mathcal{C}(t)$ or from multiplications). Each such
    multiplication then takes $\mathcal{O}(4^k)$ time by \cref{lemma:basic_ops},
    and so all multiplications will take $\mathcal{O}(4^kn)$ time for $t$ and
    $\mathcal{O}(4^knm)$ time across all $t \in \mathcal{V}(T) \setminus
    \mathcal{L}(T)$ since the number of vertices in the PJT is bounded by the
    number of variables.
  \item Each variable is projected exactly once and is always projected from
    an ADD with at most $\mathcal{O}(2^k)$ nodes. Thus, the time complexity of
    projecting all variables is $\mathcal{O}(4^km)$.
  \item In total, we get $\mathcal{O}(2^kn)$ time for constructing initial ADDs,
    $\mathcal{O}(4^knm)$ for multiplications, and $\mathcal{O}(4^km)$ for
    projections, resulting in $\mathcal{O}(4^knm)$ time in total.
  \end{itemize}
\end{proof}

\bibliographystyle{acm}
\bibliography{paper}

\end{document}